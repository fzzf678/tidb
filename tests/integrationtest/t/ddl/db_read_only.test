create database if not exists test;
drop database if exists db_read_only;
create database db_read_only;
drop database if exists db_read_only_1;
create database db_read_only_1;
use db_read_only;
create table s(a int primary key);
create table t(id int primary key auto_increment, a int, b int, c varchar(1), index b(b), foreign key fk_a(b) references s(a));
create table db_read_only_1.s(a int primary key);
alter table t add foreign key fk_a3(b) references db_read_only_1.s(a);
create view v1 as select * from t;
create table members (
    id int,
    fname varchar(255),
    lname varchar(255),
    dob date,
    data json
)
partition by range (year(dob)) (
 partition pBefore1950 values less than (1950),
 partition p1950 values less than (1960),
 partition p1960 values less than (1970),
 partition p1970 values less than (1980),
 partition p1980 values less than (1990),
 partition p1990 values less than (2000));

# test information_schema.schemata_extensions
desc information_schema.schemata_extensions;
select * from information_schema.schemata_extensions;
alter schema test read only 1;
select * from information_schema.schemata_extensions;
alter schema test read only 0;
select * from information_schema.schemata_extensions;

# DDL can NOT be executed in read-only mode
alter schema db_read_only read only 1;

# alter database
-- error 3809
alter database db_read_only charset gbk;
-- error 3809
alter database db_read_only collate utf8mb4_roman_ci;
create placement policy p1 followers=4;
-- error 3809
alter database db_read_only placement policy p1;
-- error 3809
alter database db_read_only set tiflash replica 1;
-- error 3809
drop database db_read_only;

# create table
-- error 3809
create table t1(c1 int);
-- error 3809
create table t2 like t;
-- error 3809
create table pt (a int, b int) partition by hash(a) partitions 4;

# alter table
-- error 3809
alter table t add column cc int not null;
-- error 3809
alter table t add index (a);
-- error 3809
create index c1 on t(a);
-- error 3809
alter table t alter index b invisible;
-- error 3809
alter table t change column c c varchar(10);
-- error 3809
alter table t drop column c;
-- error 3809
alter table t drop index b;
-- error 3809
drop index b on t;
-- error 3809
alter table t modify column c varchar(10);
-- error 3809
alter table t rename index b to b_1;
-- error 3809
alter table t drop foreign key fk_a;
-- error 3809
alter table t add foreign key fk_a1(b) references s(a);
-- error 3809
alter table t add foreign key fk_a2(b) references db_read_only_1.s(a);
-- error 3809
alter table t partition by hash(a) partitions 4;
-- error 3809
alter table members drop partition p1990;
-- error 3809
alter table members truncate partition p1980;
-- error 3809
alter table members add partition (partition `p1990to2010` values less than (2010));
-- error 3809
alter table members reorganize partition `p1990to2010` into
(partition p1990 values less than (2000),
 partition p2000 values less than (2010),
 partition p2010 values less than (2020),
 partition p2020 values less than (2030),
 partition pMax values less than (maxvalue));

# rename table
-- error 3809
rename table t to t_old;
# db_read_only is read only
-- error 3809
rename table db_read_only.t to db_read_only_1.t;
# db_read_only_1 is read only
alter schema db_read_only read only 0;
alter schema db_read_only_1 read only 1;
-- error 3809
rename table db_read_only.t to db_read_only_1.t;
alter schema db_read_only read only 1;

# truncate/drop table and view, load data, import, create/replace view, alter table auto_increment
-- error 3809
truncate table t;
-- error 3809
drop table t;
-- error 3809
drop view v1;
-- error 3809
load data local infile '' into table t;
-- error 3809
import into t from '';
-- error 3809
create view v as select * from t;
-- error 3809
create or replace view v as select * from t;
-- error 3809
alter table t auto_increment = 10000;

# DDL can be executed in read-only mode
# temporary table
create temporary table t(a INT);
drop temporary table t;
create global temporary table t_global(a INT) on commit delete rows;
drop global temporary table t_global;

alter table t compact tiflash replica;

# finish test
alter schema db_read_only read only 0;
alter schema db_read_only_1 read only 0;


### DML can't be executed in read-only mode
drop database if exists db1;
create database db1;
use db1;
create table t1(id int primary key, a int);
create table t2(id int, a int);
create table t3(a int);
drop database if exists db2;
create database db2;
use db2;
create table t1(id int primary key, a int);
create table t2(id int, a int);
create table t3(a int);

alter schema db1 read only 1;
use db1;

# insert
insert into t1 values(1);
insert into t1 select * from t2;
insert into t1 table t2;
insert into t1 set a=1;
insert into t1 (a) set a=1;

# replace
replace into t1 values (1 || 2)
replace into t1 table t2
replace t1 set a = default;

# delete
delete from t1;
delete t1, t2 from t1, t2;
delete db1.t1, db2.t2 from db1.t1, db2.t2;
delete t1,t2,t3 from t1, t2, t3 where t3.a < 5 and t1.a = 3;
delete t2 from t1, t2;
delete db2.t2 from db1.t1, db2.t2;
delete db1.t1 from db1.t1, db2.t2;
delete t1 from t1, t1 as t2 where t1.b = t2.b and t1.a > t2.a;
delete from t1,t2,t3 using t1,t2,t3 where t3.a = 1;
delete from t2,t3 using t1,t2,t3 where t1.a = 1;
with cte as (select * from t1) delete from t2 where t2.a in (select a from cte);

# update
update t1 set a = a + 1;
update t1, t2 set t1.a = 1, t2.a = 1 where t1.a = t2.a;
update t1 join t2 set t1.a=1 where t1.b=t2.b;
analyze table t1 update histogram on t1.a; -- success
with cte as (select * from t1) update t2 set a = 1 where t2.a in (select a from cte);

# modify columns with foreign key
alter table t1 add constraint fk_1 foreign key (id) references t2(id) on delete restrict;
alter table t1 add constraint fk_1 foreign key (id) references t2(id) on update restrict;
alter table t1 add constraint fk_1 foreign key (id) references t2(id) on delete cascade;
alter table t1 add constraint fk_1 foreign key (id) references t2(id) on update cascade;
alter table t1 add constraint fk_1 foreign key (id) references t2(id) on delete set null;
alter table t1 add constraint fk_1 foreign key (id) references t2(id) on update set null;

# for update / for share + tidb_enable_shared_lock_promotion
select * from t for update;
select * from t for update OF t WAIT 5;
select * from t1 join t2 on t1.a= t2.a for update;
select t1.a from t1 join t2 on t1.a= t2.a for update;
table t for update;
set @@session.tidb_enable_shared_lock_promotion = 1;
select * from t for share;
select * from t for share OF t WAIT 5;
select * from t1 join t2 on t1.a= t2.a for share;
select t1.a from t1 join t2 on t1.a= t2.a for share;
table t1 for share;

# select should be ok
select * from t;
select * from t1 join t2 on t1.a= t2.a;
table t;
