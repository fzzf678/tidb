package main

import (
	"context"
	"crypto/sha256"
	"encoding/binary"
	"flag"
	"fmt"
	"github.com/pingcap/tidb/br/pkg/storage"
	"log"
	"math"
	"math/rand/v2"
	"os"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/google/uuid"
)

var (
	printHelp bool

	//sessionFilename  string
	//messageFilename  string
	//feedbackFilename string

	//sessionCount int
	userIdStart int
	userIdEnd   int

	sessionSnStart    int
	sessionSnEnd      int
	s3Path            string
	sessionNumPerFile int
	workerCount       int
)

func init() {
	flag.BoolVar(&printHelp, "help", false, "print help")

	//flag.StringVar(&sessionFilename, "session-file", "chat_session.csv", "chat_session csv output filename")
	//flag.StringVar(&messageFilename, "message-file", "chat_message.csv", "chat_message csv output filename")
	//flag.StringVar(&feedbackFilename, "feedback-file", "chat_message_feedback.csv", "chat_message_feedback csv output filename")
	flag.StringVar(&s3Path, "s3Path", "gcs://global-sort-dir/fzzf678/ds/", "chat_message_feedback csv output filename")

	//flag.IntVar(&sessionCount, "session-count", 1_000, "chat_session count")
	flag.IntVar(&userIdStart, "user-id-start", 0, "start of user id range")
	flag.IntVar(&userIdEnd, "user-id-end", 500, "end of user id range")
	flag.IntVar(&sessionSnStart, "session-sn-begin", 0, "chat_session sn begin")
	flag.IntVar(&sessionSnEnd, "session-sn-end", 200_000, "chat_session sn end")
	flag.IntVar(&sessionNumPerFile, "session-num-per-file", 200_000, "chat_session sn end")
	flag.IntVar(&workerCount, "worker-count", 10, "chat_session sn end")

	flag.Parse()
	if printHelp {
		flag.PrintDefaults()
		os.Exit(0)
	}

	initUser()
}

func check[T any](val T, err error) T {
	if err != nil {
		panic(err)
	}
	return val
}

var userIds []string

func initUser() {
	userIds = make([]string, 0, userIdEnd-userIdStart)
	for i := userIdStart; i < userIdEnd; i++ {
		hash := sha256.Sum256([]byte(strconv.Itoa(i)))
		uuid := uuid.Must(uuid.FromBytes(hash[:16]))

		var id string
		x := float64(binary.BigEndian.Uint32(hash[16:20])) / math.MaxUint32
		if x < 0.3 {
			id = fmt.Sprintf("Wechat-%s", uuid.String())
		} else if x < 0.5 {
			id = fmt.Sprintf("Google-%s", uuid.String())
		} else if x < 0.55 {
			id = fmt.Sprintf("Apple-%s", uuid.String())
		} else {
			id = uuid.String()
		}

		userIds = append(userIds, id)
	}
}

func valid() string {
	if rand.Float64() < 0.15 {
		return "NULL"
	}
	return "1"
}

func uuidBytes() []byte {
	return check(uuid.Must(uuid.NewRandom()).MarshalBinary())
}

func c() string {
	if rand.Float64() < 0.1 {
		return fmt.Sprintf("0x%X", uuidBytes())
	}
	return "NULL"
}

// func main() {
func genData(fileNameSuffix, sessionSn int) {
	log.Printf("Generating data for file %d, sessionSn from [%d, %d)\n",
		fileNameSuffix, sessionSn, sessionSn+sessionNumPerFile)
	// mostly generated by DeepSeek-R1

	//sessionFile := check(os.OpenFile(fileName+sessionFilename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0o666))
	//messageFile := check(os.OpenFile(fileName+messageFilename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0o666))
	//feedbackFile := check(os.OpenFile(fileName+feedbackFilename, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0o666))
	//
	//defer sessionFile.Close()
	//defer messageFile.Close()
	//defer feedbackFile.Close()

	//sessionW := bufio.NewWriter(sessionFile)
	//messageW := bufio.NewWriter(messageFile)
	//feedbackW := bufio.NewWriter(feedbackFile)

	//fmt.Fprintln(sessionW, "inserted_at,updated_at,id,sn,valid,user_id,s,c,title,title_type,version,current_message_id")
	//fmt.Fprintln(messageW, "inserted_at,updated_at,chat_session_id,user_id,message_id,parent_id,model,role,s,e,f,has_feedback,f_id,f_info,t_flag,t_val,s_flag,s_id,s_status,t0,t1")
	//fmt.Fprintln(feedbackW, "inserted_at,updated_at,user_id,chat_session_id,message_id,feedback_type,feedback_tag,description")

	var (
		sessionBuilder  strings.Builder
		messageBuilder  strings.Builder
		feedbackBuilder strings.Builder
	)

	for i := 0; i < sessionNumPerFile; i++ {
		now := time.Now().UTC().Format("2006-01-02 15:04:05")
		userId := randomPick(userIds)
		sessionId := uuid.Must(uuid.NewRandom()).String()
		messageCount := 2 + rand.IntN(5)*2 // 2/4/6/8/10

		// 生成会话记录
		sessionBuilder.WriteString(fmt.Sprintf("%s,%s,", now, now))
		sessionBuilder.WriteString(fmt.Sprintf("%s,%d,%s,%s,", sessionId, sessionSn, valid(), userId))
		sessionBuilder.WriteString(fmt.Sprintf("2,%s,", c()))
		sessionBuilder.WriteString(fmt.Sprintf("%q,2,", randomString(10, 20)))
		sessionBuilder.WriteString(fmt.Sprintf("%d,%d\n", messageCount/2, messageCount))

		// 生成消息记录
		for messageID := 1; messageID <= messageCount; messageID += 2 {
			userMessageID := messageID
			assistantMessageID := messageID + 1

			// 用户消息
			messageBuilder.WriteString(fmt.Sprintf("%s,%s,", now, now))
			messageBuilder.WriteString(fmt.Sprintf("%s,%s,%d,", sessionId, userId, userMessageID))
			messageBuilder.WriteString(fmt.Sprintf("%d,", userMessageID-1))
			messageBuilder.WriteString(fmt.Sprintf("NULL,USER,1,NULL,NULL,0,"))

			// f_id和f_info
			var fIDStr, fInfoStr string
			if rand.Float64() < 0.2 {
				fID := uuid.Must(uuid.NewRandom())
				fIDBytes, _ := fID.MarshalBinary()
				fIDStr = fmt.Sprintf("0x%X", fIDBytes)
				if rand.Float64() < 0.01 {
					fInfoStr = fmt.Sprintf(`"{\"v1\":%d,\"v2\":%d,\"v3\":%f,\"v4\":\"%s\"}"`,
						rand.IntN(1048576), rand.IntN(1048576), rand.Float64(), randomString(2, 10))
				} else {
					fInfoStr = "NULL"
				}
			} else {
				fIDStr, fInfoStr = "NULL", "NULL"
			}
			messageBuilder.WriteString(fmt.Sprintf("%s,%s,", fIDStr, fInfoStr))
			messageBuilder.WriteString(fmt.Sprintf("0,0,0,NULL,NULL,0,0\n"))

			// 助手消息
			messageBuilder.WriteString(fmt.Sprintf("%s,%s,", now, now))
			messageBuilder.WriteString(fmt.Sprintf("%s,%s,%d,%d,", sessionId, userId, assistantMessageID, userMessageID))
			messageBuilder.WriteString(fmt.Sprintf("NULL,ASSITANT,2,"))

			// e字段
			var eStr string
			if rand.Float64() < 0.005 {
				eStr = fmt.Sprintf("%q", randomString(50, 200))
			} else {
				eStr = "NULL"
			}
			messageBuilder.WriteString(fmt.Sprintf("%s,", eStr))

			// f字段
			fValues := []string{"1", "2", "3"}
			f := fValues[rand.IntN(len(fValues))]
			messageBuilder.WriteString(fmt.Sprintf("%s,", f))

			// has_feedback
			hasFeedback := 0
			if rand.Float64() < 0.1 {
				hasFeedback = 1

				// 生成反馈记录
				feedbackType := "GOOD"
				if rand.Float64() < 0.5 {
					feedbackType = "BAD"
				}
				var feedbackTag, description string
				if feedbackType == "BAD" {
					if rand.Float64() < 0.5 {
						feedbackTag = randomPick([]string{"harmful", "nonsense", "fake", "other"})
					}
					if rand.Float64() < 0.2 {
						description = randomString(1, 50)
					}
				}

				feedbackBuilder.WriteString(fmt.Sprintf("%s,%s,", now, now))
				feedbackBuilder.WriteString(fmt.Sprintf("%s,%s,%d,", userId, sessionId, assistantMessageID))
				feedbackBuilder.WriteString(fmt.Sprintf("%s,", feedbackType))
				if feedbackTag != "" {
					feedbackBuilder.WriteString(fmt.Sprintf("%s,", feedbackTag))
				} else {
					feedbackBuilder.WriteString(fmt.Sprintf("NULL,"))
				}
				if description != "" {
					feedbackBuilder.WriteString(fmt.Sprintf("%q\n", description))
				} else {
					feedbackBuilder.WriteString(fmt.Sprintf("NULL\n"))
				}
			}
			messageBuilder.WriteString(fmt.Sprintf("%d,NULL,NULL,", hasFeedback))

			// t_flag和t_val
			messageBuilder.WriteString(fmt.Sprintf("%d,%f,", rand.IntN(2), rand.Float64()))

			// s_flag, s_id, s_status
			sFlag := rand.IntN(2)
			sID := uuid.Must(uuid.NewRandom())
			sIDBytes, _ := sID.MarshalBinary()
			sStatus := []string{"1", "2", "3", "4"}[rand.IntN(4)]
			messageBuilder.WriteString(fmt.Sprintf("%d,0x%X,%s,", sFlag, sIDBytes, sStatus))

			// t0和t1
			messageBuilder.WriteString(fmt.Sprintf("%d,%d\n", rand.IntN(1024), rand.IntN(65536)))
		}

		sessionSn++
	}

	writeDataToS3(fmt.Sprintf("chat_session/chat_session.%09d.csv", fileNameSuffix), sessionBuilder)
	writeDataToS3(fmt.Sprintf("chat_message/chat_message.%09d.csv", fileNameSuffix), messageBuilder)
	writeDataToS3(fmt.Sprintf("chat_message_feedback/chat_message_feedback.%09d.csv", fileNameSuffix), feedbackBuilder)
}

func createExternalStorage() storage.ExternalStorage {
	op := storage.BackendOptions{S3: storage.S3BackendOptions{
		//Region:          *s3Region,
		//AccessKey:       *s3AccessKey,
		//SecretAccessKey: *s3SecretKey,
		//Provider:        *s3Provider,
		//Endpoint:        *s3Endpoint,
	}}
	s, err := storage.ParseBackend(s3Path, &op)
	if err != nil {
		panic(err)
	}
	store, err := storage.NewWithDefaultOpt(context.Background(), s)
	if err != nil {
		panic(err)
	}
	return store
}

func writeDataToS3(fileName string, builder strings.Builder) error {
	store := createExternalStorage()
	writer, err := store.Create(context.Background(), fileName, nil)
	if err != nil {
		return fmt.Errorf("failed to create S3 file: %w", err)
	}
	defer writer.Close(context.Background())

	for i := 0; i < 3; i++ {
		_, err = writer.Write(context.Background(), []byte(builder.String()))
		if err == nil {
			return nil
		}
		log.Printf("Write to S3 failed, deleting file: %s", fileName)
		store.DeleteFile(context.Background(), fileName) // Delete the file if write fails
	}
	log.Printf("Write to S3 failed 3 times, giving up: %s", fileName)
	return nil
}

type task struct {
	fileNameSuffix int
	sessionSnStart int
}

func main() {
	if (sessionSnEnd-sessionSnStart)%sessionNumPerFile != 0 {
		panic("sessionSnEnd - sessionSnStart must be a multiple of sessionNumPerFile")
	}
	timeStart := time.Now()
	ch := make(chan *task)
	wg := sync.WaitGroup{}

	for i := 0; i < workerCount; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			for t := range ch {
				genData(t.fileNameSuffix, t.sessionSnStart)
			}
		}()
	}

	for i := sessionSnStart; i < sessionSnEnd; i += sessionNumPerFile {
		ch <- &task{
			fileNameSuffix: i / sessionNumPerFile,
			sessionSnStart: i,
		}
	}
	close(ch)

	wg.Wait()
	log.Printf("Time elapsed: %v for %d rows", time.Since(timeStart), sessionSnEnd-sessionSnStart)
}
